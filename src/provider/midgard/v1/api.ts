/* tslint:disable */
/* eslint-disable */
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the Bifr√∂st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 0.8.1
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AssetDetail
 */
export interface AssetDetail {
    /**
     * 
     * @type {string}
     * @memberof AssetDetail
     */
    asset?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetDetail
     */
    dateCreated?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetDetail
     */
    priceRune?: string;
}
/**
 * 
 * @export
 * @interface BlockRewards
 */
export interface BlockRewards {
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    blockReward?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    bondReward?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockRewards
     */
    stakeReward?: string;
}
/**
 * 
 * @export
 * @interface BondMetrics
 */
export interface BondMetrics {
    /**
     * Average bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageActiveBond?: string;
    /**
     * Average bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    averageStandbyBond?: string;
    /**
     * Maxinum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumActiveBond?: string;
    /**
     * Maximum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    maximumStandbyBond?: string;
    /**
     * Median bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianActiveBond?: string;
    /**
     * Median bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    medianStandbyBond?: string;
    /**
     * Minumum bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumActiveBond?: string;
    /**
     * Minumum bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    minimumStandbyBond?: string;
    /**
     * Total bond of active nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalActiveBond?: string;
    /**
     * Total bond of standby nodes
     * @type {string}
     * @memberof BondMetrics
     */
    totalStandbyBond?: string;
}
/**
 * 
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof Coin
     */
    asset?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    fee?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    slip?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    stakeUnits?: string;
}
/**
 * 
 * @export
 * @interface Gas
 */
export interface Gas {
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof Gas
     */
    asset?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    catching_up?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse200
     */
    database?: boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    scannerHeight?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count?: number;
    /**
     * 
     * @type {Array<TxDetails>}
     * @memberof InlineResponse2001
     */
    txs?: Array<TxDetails>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    error: string;
}
/**
 * 
 * @export
 * @interface NetworkInfo
 */
export interface NetworkInfo {
    /**
     * Array of Active Bonds
     * @type {Array<string>}
     * @memberof NetworkInfo
     */
    activeBonds?: Array<string>;
    /**
     * Number of Active Nodes
     * @type {number}
     * @memberof NetworkInfo
     */
    activeNodeCount?: number;
    /**
     * 
     * @type {BlockRewards}
     * @memberof NetworkInfo
     */
    blockRewards?: BlockRewards;
    /**
     * 
     * @type {BondMetrics}
     * @memberof NetworkInfo
     */
    bondMetrics?: BondMetrics;
    /**
     * (1 + (bondReward * blocksPerMonth/totalActiveBond)) ^ 12 -1
     * @type {string}
     * @memberof NetworkInfo
     */
    bondingAPY?: string;
    /**
     * (1 + (stakeReward * blocksPerMonth/totalDepth of active pools)) ^ 12 -1
     * @type {string}
     * @memberof NetworkInfo
     */
    liquidityAPY?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    nextChurnHeight?: string;
    /**
     * The remaining time of pool activation (in blocks)
     * @type {number}
     * @memberof NetworkInfo
     */
    poolActivationCountdown?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkInfo
     */
    poolShareFactor?: string;
    /**
     * Array of Standby Bonds
     * @type {Array<string>}
     * @memberof NetworkInfo
     */
    standbyBonds?: Array<string>;
    /**
     * Number of Standby Nodes
     * @type {number}
     * @memberof NetworkInfo
     */
    standbyNodeCount?: number;
    /**
     * Total left in Reserve
     * @type {string}
     * @memberof NetworkInfo
     */
    totalReserve?: string;
    /**
     * Total Rune Staked in Pools
     * @type {string}
     * @memberof NetworkInfo
     */
    totalStaked?: string;
}
/**
 * 
 * @export
 * @interface NodeKey
 */
export interface NodeKey {
    /**
     * ed25519 public key
     * @type {string}
     * @memberof NodeKey
     */
    ed25519?: string;
    /**
     * secp256k1 public key
     * @type {string}
     * @memberof NodeKey
     */
    secp256k1?: string;
}
/**
 * 
 * @export
 * @interface Option
 */
export interface Option {
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    asymmetry?: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    priceTarget?: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof Option
     */
    withdrawBasisPoints?: string;
}
/**
 * 
 * @export
 * @interface PoolAggChanges
 */
export interface PoolAggChanges {
    /**
     * Total changes in asset depth at this time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetChanges?: string;
    /**
     * Depth of asset at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetDepth?: string;
    /**
     * Total asset staked
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetStaked?: string;
    /**
     * Total asset withdrawn
     * @type {string}
     * @memberof PoolAggChanges
     */
    assetWithdrawn?: string;
    /**
     * Count of buy swaps
     * @type {number}
     * @memberof PoolAggChanges
     */
    buyCount?: number;
    /**
     * Sum of \"rune_amount\" of buy swap events
     * @type {string}
     * @memberof PoolAggChanges
     */
    buyVolume?: string;
    /**
     * Total amount of rune, paid by the network to neutralize \"gasUsed\" changes
     * @type {string}
     * @memberof PoolAggChanges
     */
    gasReplenished?: string;
    /**
     * Total amount of asset used as gas for network transactions (e.g. BNB.BNB, ETH.ETH)
     * @type {string}
     * @memberof PoolAggChanges
     */
    gasUsed?: string;
    /**
     * buyVolume + sellVolume
     * @type {string}
     * @memberof PoolAggChanges
     */
    poolVolume?: string;
    /**
     * Asset price in rune at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    price?: string;
    /**
     * Sum of \"rewards\" events in rune
     * @type {string}
     * @memberof PoolAggChanges
     */
    reward?: string;
    /**
     * Total changes in rune depth at this time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeChanges?: string;
    /**
     * Depth of rune at the end of current time bucket
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeDepth?: string;
    /**
     * Total rune staked
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeStaked?: string;
    /**
     * Total rune withdrawn
     * @type {string}
     * @memberof PoolAggChanges
     */
    runeWithdrawn?: string;
    /**
     * Count of sell swaps
     * @type {number}
     * @memberof PoolAggChanges
     */
    sellCount?: number;
    /**
     * Sum of \"rune_amount\" of sell swap events
     * @type {string}
     * @memberof PoolAggChanges
     */
    sellVolume?: string;
    /**
     * Count of stake events
     * @type {number}
     * @memberof PoolAggChanges
     */
    stakeCount?: number;
    /**
     * Determining end of current time bucket in unix timestamp
     * @type {number}
     * @memberof PoolAggChanges
     */
    time?: number;
    /**
     * Total changes in pool units (stakes/withdraws)
     * @type {string}
     * @memberof PoolAggChanges
     */
    unitsChanges?: string;
    /**
     * Count of withdraw events
     * @type {number}
     * @memberof PoolAggChanges
     */
    withdrawCount?: number;
}
/**
 * 
 * @export
 * @interface PoolDetail
 */
export interface PoolDetail {
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    asset?: string;
    /**
     * Total current Asset balance
     * @type {string}
     * @memberof PoolDetail
     */
    assetDepth?: string;
    /**
     * Amount of pool asset balance changed by fee, gas and assset donation
     * @type {string}
     * @memberof PoolDetail
     */
    assetEarned?: string;
    /**
     * Total Asset staked
     * @type {string}
     * @memberof PoolDetail
     */
    assetStakedTotal?: string;
    /**
     * Number of RUNE->ASSET transactions
     * @type {string}
     * @memberof PoolDetail
     */
    buyAssetCount?: string;
    /**
     * Average sell Asset fee size for RUNE->ASSET (in ASSET)
     * @type {string}
     * @memberof PoolDetail
     */
    buyFeeAverage?: string;
    /**
     * Total fees (in Asset)
     * @type {string}
     * @memberof PoolDetail
     */
    buyFeesTotal?: string;
    /**
     * Average trade slip for RUNE->ASSET in %
     * @type {string}
     * @memberof PoolDetail
     */
    buySlipAverage?: string;
    /**
     * Average Asset buy transaction size for (RUNE->ASSET) (in ASSET)
     * @type {string}
     * @memberof PoolDetail
     */
    buyTxAverage?: string;
    /**
     * Total Asset buy volume (RUNE->ASSET) (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    buyVolume?: string;
    /**
     * (1 + (poolEarned/poolDepth)) ^ 12 -1
     * @type {string}
     * @memberof PoolDetail
     */
    poolAPY?: string;
    /**
     * Total depth of both sides (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolDepth?: string;
    /**
     * (assetEarned * price) + runeEarned
     * @type {string}
     * @memberof PoolDetail
     */
    poolEarned?: string;
    /**
     * Average pool fee
     * @type {string}
     * @memberof PoolDetail
     */
    poolFeeAverage?: string;
    /**
     * Total fees
     * @type {string}
     * @memberof PoolDetail
     */
    poolFeesTotal?: string;
    /**
     * Average pool slip
     * @type {string}
     * @memberof PoolDetail
     */
    poolSlipAverage?: string;
    /**
     * Rune value staked Total
     * @type {string}
     * @memberof PoolDetail
     */
    poolStakedTotal?: string;
    /**
     * Average pool transaction
     * @type {string}
     * @memberof PoolDetail
     */
    poolTxAverage?: string;
    /**
     * Total pool units outstanding
     * @type {string}
     * @memberof PoolDetail
     */
    poolUnits?: string;
    /**
     * Two-way volume of all-time (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolVolume?: string;
    /**
     * Two-way volume in 24hrs (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    poolVolume24hr?: string;
    /**
     * Price of Asset (in RUNE).
     * @type {string}
     * @memberof PoolDetail
     */
    price?: string;
    /**
     * Total current Rune balance
     * @type {string}
     * @memberof PoolDetail
     */
    runeDepth?: string;
    /**
     * Amount of pool rune balance changed by fee,reward, deficit, gas and rune donation
     * @type {string}
     * @memberof PoolDetail
     */
    runeEarned?: string;
    /**
     * Total RUNE staked
     * @type {string}
     * @memberof PoolDetail
     */
    runeStakedTotal?: string;
    /**
     * Number of ASSET->RUNE transactions
     * @type {string}
     * @memberof PoolDetail
     */
    sellAssetCount?: string;
    /**
     * Average buy Asset fee size for ASSET->RUNE (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellFeeAverage?: string;
    /**
     * Total fees (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellFeesTotal?: string;
    /**
     * Average trade slip for ASSET->RUNE in %
     * @type {string}
     * @memberof PoolDetail
     */
    sellSlipAverage?: string;
    /**
     * Average Asset sell transaction size (ASSET>RUNE) (in RUNE)
     * @type {string}
     * @memberof PoolDetail
     */
    sellTxAverage?: string;
    /**
     * Total Asset sell volume (ASSET>RUNE) (in RUNE).
     * @type {string}
     * @memberof PoolDetail
     */
    sellVolume?: string;
    /**
     * Number of stake transactions
     * @type {string}
     * @memberof PoolDetail
     */
    stakeTxCount?: string;
    /**
     * Number of unique stakers
     * @type {string}
     * @memberof PoolDetail
     */
    stakersCount?: string;
    /**
     * Number of stake & withdraw transactions
     * @type {string}
     * @memberof PoolDetail
     */
    stakingTxCount?: string;
    /**
     * 
     * @type {string}
     * @memberof PoolDetail
     */
    status?: PoolDetailStatusEnum;
    /**
     * Number of unique swappers interacting with pool
     * @type {string}
     * @memberof PoolDetail
     */
    swappersCount?: string;
    /**
     * Number of swapping transactions in the pool (buys and sells)
     * @type {string}
     * @memberof PoolDetail
     */
    swappingTxCount?: string;
    /**
     * Number of withdraw transactions
     * @type {string}
     * @memberof PoolDetail
     */
    withdrawTxCount?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PoolDetailStatusEnum {
    Bootstrapped = 'bootstrapped',
    Enabled = 'enabled',
    Disabled = 'disabled'
}

/**
 * 
 * @export
 * @interface PoolEarningDetail
 */
export interface PoolEarningDetail {
    /**
     * number of days that pool was enabled in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthActiveDays?: string;
    /**
     * sum of asset donated to the pool by add event in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthAssetDonation?: string;
    /**
     * sum of buy fee in rune in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthBuyFee?: string;
    /**
     * sum of gas paid from asset of this pool in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthGasPaid?: string;
    /**
     * sum of gas reimbursed to rune of this pool in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthGasReimbursed?: string;
    /**
     * sum of pool deficit in reward event in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthPoolDeficit?: string;
    /**
     * sum of donation to this pool in past 30 days (lastMonthAssetDonation*price + lastMonthRuneDonation)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthPoolDonation?: string;
    /**
     * sum of pool Earning in past 30 days (lastMonthPoolDonation + lastMonthPoolFee + lastMonthReward + lastMonthPoolDeficit + lastMonthGasReimbursed - (lastMonthGasPaid * price))
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthPoolEarning?: string;
    /**
     * sum of pool sell fee in rune in past 30 days (lastMonthBuyFee+lastMonthSellFee)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthPoolFee?: string;
    /**
     * sum of rewards in reward event in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthReward?: string;
    /**
     * sum of rune donated to the pool by add event in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthRuneDonation?: string;
    /**
     * sum of sell fee in rune in past 30 days
     * @type {string}
     * @memberof PoolEarningDetail
     */
    lastMonthSellFee?: string;
    /**
     * lastMonthPoolEarning/poolDepth (lastMonthPoolEarning may extrapolate if pool was active less than 30 days)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    periodicRate?: string;
    /**
     * pool name
     * @type {string}
     * @memberof PoolEarningDetail
     */
    pool?: string;
    /**
     * (1 + periodicRate ) ^ 12 -1
     * @type {string}
     * @memberof PoolEarningDetail
     */
    poolAPY?: string;
    /**
     * pool depth (2 * rune depth)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    poolDepth?: string;
    /**
     * pool price in rune
     * @type {string}
     * @memberof PoolEarningDetail
     */
    price?: string;
    /**
     * sum of asset donated to the pool by add event
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalAssetDonation?: string;
    /**
     * sum of buy fee in rune
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalBuyFee?: string;
    /**
     * sum of gas paid from asset of this pool
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalGasPaid?: string;
    /**
     * sum of gas reimbursed to rune of this pool
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalGasReimbursed?: string;
    /**
     * sum of pool deficit in reward event
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalPoolDeficit?: string;
    /**
     * sum of donation to this pool (totalAssetDonation*price + totalRuneDonation)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalPoolDonation?: string;
    /**
     * sum of pool Earning (totalPoolDonation+totalPoolFee + totalReward + totalPoolDeficit + totalGasReimbursed - (totalGasPaid * price))
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalPoolEarning?: string;
    /**
     * sum of pool sell fee in rune (sellFee+buyFee)
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalPoolFee?: string;
    /**
     * sum of rewards in reward event
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalReward?: string;
    /**
     * sum of rune donated to the pool by add event
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalRuneDonation?: string;
    /**
     * sum of sell fee in rune
     * @type {string}
     * @memberof PoolEarningDetail
     */
    totalSellFee?: string;
}
/**
 * 
 * @export
 * @interface StakersAddressData
 */
export interface StakersAddressData {
    /**
     * 
     * @type {Array<string>}
     * @memberof StakersAddressData
     */
    poolsArray?: Array<string>;
    /**
     * Total value of earnings (in RUNE) across all pools.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalEarned?: string;
    /**
     * Average of all pool ROIs.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalROI?: string;
    /**
     * Total staked (in RUNE) across all pools.
     * @type {string}
     * @memberof StakersAddressData
     */
    totalStaked?: string;
}
/**
 * 
 * @export
 * @interface StakersAssetData
 */
export interface StakersAssetData {
    /**
     * 
     * @type {string}
     * @memberof StakersAssetData
     */
    asset?: string;
    /**
     * Total of assets staked
     * @type {string}
     * @memberof StakersAssetData
     */
    assetStaked?: string;
    /**
     * Total of assets withdrawn
     * @type {string}
     * @memberof StakersAssetData
     */
    assetWithdrawn?: string;
    /**
     * 
     * @type {number}
     * @memberof StakersAssetData
     */
    dateFirstStaked?: number;
    /**
     * 
     * @type {number}
     * @memberof StakersAssetData
     */
    heightLastStaked?: number;
    /**
     * Total of rune staked
     * @type {string}
     * @memberof StakersAssetData
     */
    runeStaked?: string;
    /**
     * Total of rune withdrawn
     * @type {string}
     * @memberof StakersAssetData
     */
    runeWithdrawn?: string;
    /**
     * Represents ownership of a pool.
     * @type {string}
     * @memberof StakersAssetData
     */
    units?: string;
}
/**
 * 
 * @export
 * @interface StatsChanges
 */
export interface StatsChanges {
    /**
     * Count of buy swaps
     * @type {number}
     * @memberof StatsChanges
     */
    buyCount?: number;
    /**
     * Sum of \"rune_amount\" of buy swap events
     * @type {string}
     * @memberof StatsChanges
     */
    buyVolume?: string;
    /**
     * Determining end height of current time bucket
     * @type {number}
     * @memberof StatsChanges
     */
    endHeight?: number;
    /**
     * Count of sell swaps
     * @type {number}
     * @memberof StatsChanges
     */
    sellCount?: number;
    /**
     * Sum of \"rune_amount\" of sell swap events
     * @type {string}
     * @memberof StatsChanges
     */
    sellVolume?: string;
    /**
     * Count of stake events
     * @type {number}
     * @memberof StatsChanges
     */
    stakeCount?: number;
    /**
     * Determining start height of current time bucket
     * @type {number}
     * @memberof StatsChanges
     */
    startHeight?: number;
    /**
     * Determining end of current time bucket in unix timestamp
     * @type {number}
     * @memberof StatsChanges
     */
    time?: number;
    /**
     * Total deficit of all pools in the current time bucket
     * @type {string}
     * @memberof StatsChanges
     */
    totalDeficit?: string;
    /**
     * Total reward of all pools in the current time bucket
     * @type {string}
     * @memberof StatsChanges
     */
    totalReward?: string;
    /**
     * Total rune depth of all pools at the end of current time bucket
     * @type {string}
     * @memberof StatsChanges
     */
    totalRuneDepth?: string;
    /**
     * buyVolume + sellVolume
     * @type {string}
     * @memberof StatsChanges
     */
    totalVolume?: string;
    /**
     * Count of withdraw events
     * @type {number}
     * @memberof StatsChanges
     */
    withdrawCount?: number;
}
/**
 * 
 * @export
 * @interface StatsData
 */
export interface StatsData {
    /**
     * Daily active users (unique addresses interacting)
     * @type {string}
     * @memberof StatsData
     */
    dailyActiveUsers?: string;
    /**
     * Daily transactions
     * @type {string}
     * @memberof StatsData
     */
    dailyTx?: string;
    /**
     * Monthly active users
     * @type {string}
     * @memberof StatsData
     */
    monthlyActiveUsers?: string;
    /**
     * Monthly transactions
     * @type {string}
     * @memberof StatsData
     */
    monthlyTx?: string;
    /**
     * Number of active pools
     * @type {string}
     * @memberof StatsData
     */
    poolCount?: string;
    /**
     * Total buying transactions
     * @type {string}
     * @memberof StatsData
     */
    totalAssetBuys?: string;
    /**
     * Total selling transactions
     * @type {string}
     * @memberof StatsData
     */
    totalAssetSells?: string;
    /**
     * Total RUNE balances
     * @type {string}
     * @memberof StatsData
     */
    totalDepth?: string;
    /**
     * Total earned (in RUNE Value).
     * @type {string}
     * @memberof StatsData
     */
    totalEarned?: string;
    /**
     * Total staking transactions
     * @type {string}
     * @memberof StatsData
     */
    totalStakeTx?: string;
    /**
     * Total staked (in RUNE Value).
     * @type {string}
     * @memberof StatsData
     */
    totalStaked?: string;
    /**
     * Total transactions
     * @type {string}
     * @memberof StatsData
     */
    totalTx?: string;
    /**
     * Total unique swappers & stakers
     * @type {string}
     * @memberof StatsData
     */
    totalUsers?: string;
    /**
     * Total (in RUNE Value) of all assets swapped since start.
     * @type {string}
     * @memberof StatsData
     */
    totalVolume?: string;
    /**
     * Total (in RUNE Value) of all assets swapped in 24hrs
     * @type {string}
     * @memberof StatsData
     */
    totalVolume24hr?: string;
    /**
     * Total withdrawing transactions
     * @type {string}
     * @memberof StatsData
     */
    totalWithdrawTx?: string;
}
/**
 * 
 * @export
 * @interface ThorchainBooleanConstants
 */
export interface ThorchainBooleanConstants {
    /**
     * 
     * @type {boolean}
     * @memberof ThorchainBooleanConstants
     */
    StrictBondStakeRatio?: boolean;
}
/**
 * 
 * @export
 * @interface ThorchainConstants
 */
export interface ThorchainConstants {
    /**
     * 
     * @type {ThorchainBooleanConstants}
     * @memberof ThorchainConstants
     */
    bool_values?: ThorchainBooleanConstants;
    /**
     * 
     * @type {ThorchainInt64Constants}
     * @memberof ThorchainConstants
     */
    int_64_values?: ThorchainInt64Constants;
    /**
     * 
     * @type {ThorchainStringConstants}
     * @memberof ThorchainConstants
     */
    string_values?: ThorchainStringConstants;
}
/**
 * 
 * @export
 * @interface ThorchainEndpoint
 */
export interface ThorchainEndpoint {
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    chain?: string;
    /**
     * 
     * @type {string}
     * @memberof ThorchainEndpoint
     */
    pub_key?: string;
}
/**
 * 
 * @export
 * @interface ThorchainEndpoints
 */
export interface ThorchainEndpoints {
    /**
     * 
     * @type {Array<ThorchainEndpoint>}
     * @memberof ThorchainEndpoints
     */
    current?: Array<ThorchainEndpoint>;
}
/**
 * 
 * @export
 * @interface ThorchainInt64Constants
 */
export interface ThorchainInt64Constants {
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    BadValidatorRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    BlocksPerYear?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    DesireValidatorSet?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    DoubleSignMaxAge?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    EmissionCurve?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    FailKeySignSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    FailKeygenSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    FundMigrationInterval?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    JailTimeKeygen?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    JailTimeKeysign?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    LackOfObservationPenalty?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    MinimumBondInRune?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    MinimumNodesForBFT?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    MinimumNodesForYggdrasil?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    NewPoolCycle?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    ObserveSlashPoints?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    OldValidatorRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    RotatePerBlockHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    RotateRetryBlocks?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    SigningTransactionPeriod?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    StakeLockUpBlocks?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    TransactionFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    ValidatorRotateInNumBeforeFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    ValidatorRotateNumAfterFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    ValidatorRotateOutNumBeforeFull?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    WhiteListGasAsset?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainInt64Constants
     */
    YggFundLimit?: number;
}
/**
 * 
 * @export
 * @interface ThorchainLastblock
 */
export interface ThorchainLastblock {
    /**
     * 
     * @type {string}
     * @memberof ThorchainLastblock
     */
    chain?: string;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    lastobservedin?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    lastsignedout?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainLastblock
     */
    thorchain?: number;
}
/**
 * 
 * @export
 * @interface ThorchainQueue
 */
export interface ThorchainQueue {
    /**
     * 
     * @type {number}
     * @memberof ThorchainQueue
     */
    outbound?: number;
    /**
     * 
     * @type {number}
     * @memberof ThorchainQueue
     */
    swap?: number;
}
/**
 * 
 * @export
 * @interface ThorchainStringConstants
 */
export interface ThorchainStringConstants {
    /**
     * 
     * @type {string}
     * @memberof ThorchainStringConstants
     */
    DefaultPoolStatus?: string;
}
/**
 * 
 * @export
 * @interface TotalVolChanges
 */
export interface TotalVolChanges {
    /**
     * Sum of \"rune_amount\" of buy swap events
     * @type {string}
     * @memberof TotalVolChanges
     */
    buyVolume?: string;
    /**
     * Sum of \"rune_amount\" of sell swap events
     * @type {string}
     * @memberof TotalVolChanges
     */
    sellVolume?: string;
    /**
     * Determining end of current time bucket in unix timestamp
     * @type {number}
     * @memberof TotalVolChanges
     */
    time?: number;
    /**
     * buyVolume + sellVolume
     * @type {string}
     * @memberof TotalVolChanges
     */
    totalVolume?: string;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    address?: string;
    /**
     * 
     * @type {Array<Coin>}
     * @memberof Tx
     */
    coins?: Array<Coin>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    txID?: string;
}
/**
 * 
 * @export
 * @interface TxDetails
 */
export interface TxDetails {
    /**
     * 
     * @type {number}
     * @memberof TxDetails
     */
    date?: number;
    /**
     * 
     * @type {Event}
     * @memberof TxDetails
     */
    events?: Event;
    /**
     * 
     * @type {Gas}
     * @memberof TxDetails
     */
    gas?: Gas;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    height?: string;
    /**
     * 
     * @type {Tx}
     * @memberof TxDetails
     */
    _in?: Tx;
    ['in']?: Tx;
    /**
     * 
     * @type {Option}
     * @memberof TxDetails
     */
    options?: Option;
    /**
     * 
     * @type {Array<Tx>}
     * @memberof TxDetails
     */
    out?: Array<Tx>;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    status?: TxDetailsStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TxDetails
     */
    type?: TxDetailsTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TxDetailsStatusEnum {
    Success = 'Success',
    Refund = 'refund',
    Pending = 'Pending'
}
/**
    * @export
    * @enum {string}
    */
export enum TxDetailsTypeEnum {
    Swap = 'swap',
    Stake = 'stake',
    Unstake = 'unstake',
    Rewards = 'rewards',
    Add = 'add',
    Pool = 'pool',
    Gas = 'gas',
    Refund = 'refund',
    DoubleSwap = 'doubleSwap'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInfo: async (asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getAssetInfo', 'asset', asset)
            const localVarPath = `/v1/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns earning report and apy of the specified pool.
         * @summary Get Pool Earning Detail
         * @param {string} pool Pool asset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningDetail: async (pool: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pool' is not null or undefined
            assertParamExists('getEarningDetail', 'pool', pool)
            const localVarPath = `/v1/pools/details/{pool}/earnings`
                .replace(`{${"pool"}}`, encodeURIComponent(String(pool)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolAggChanges: async (pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pool' is not null or undefined
            assertParamExists('getPoolAggChanges', 'pool', pool)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getPoolAggChanges', 'interval', interval)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getPoolAggChanges', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getPoolAggChanges', 'to', to)
            const localVarPath = `/v1/history/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {'enabled' | 'bootstrap' | 'suspended'} [status] Pool status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: async (status?: 'enabled' | 'bootstrap' | 'suspended', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolsDetails: async (asset: string, view?: 'balances' | 'simple' | 'full', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getPoolsDetails', 'asset', asset)
            const localVarPath = `/v1/pools/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressAndAssetData: async (address: string, asset: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStakersAddressAndAssetData', 'address', address)
            // verify required parameter 'asset' is not null or undefined
            assertParamExists('getStakersAddressAndAssetData', 'asset', asset)
            const localVarPath = `/v1/stakers/{address}/pools`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressData: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getStakersAddressData', 'address', address)
            const localVarPath = `/v1/stakers/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stakers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns stats and total changes of all pools in specified interval
         * @summary Get Stats Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsChanges: async (interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getStatsChanges', 'interval', interval)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getStatsChanges', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getStatsChanges', 'to', to)
            const localVarPath = `/v1/history/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedConstants: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedEndpoints: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/thorchain/pool_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedLastblock: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a proxied endpoint for the queue endpoint from a local thornode
         * @summary Get the Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedQueue: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalVolChanges: async (interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getTotalVolChanges', 'interval', interval)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getTotalVolChanges', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getTotalVolChanges', 'to', to)
            const localVarPath = `/v1/history/total_volume`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDetails: async (offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getTxDetails', 'offset', offset)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getTxDetails', 'limit', limit)
            const localVarPath = `/v1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }

            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetInfo(asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssetDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetInfo(asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns earning report and apy of the specified pool.
         * @summary Get Pool Earning Detail
         * @param {string} pool Pool asset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEarningDetail(pool: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolEarningDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEarningDetail(pool, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PoolAggChanges>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolAggChanges(pool, interval, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {'enabled' | 'bootstrap' | 'suspended'} [status] Pool status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPools(status?: 'enabled' | 'bootstrap' | 'suspended', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PoolDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolsDetails(asset, view, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakersAddressAndAssetData(address: string, asset: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StakersAssetData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakersAddressAndAssetData(address, asset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakersAddressData(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StakersAddressData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakersAddressData(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStakersData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakersData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns stats and total changes of all pools in specified interval
         * @summary Get Stats Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatsChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatsChanges>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsChanges(interval, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThorchainProxiedConstants(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainConstants>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThorchainProxiedConstants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThorchainProxiedEndpoints(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainEndpoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThorchainProxiedEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThorchainProxiedLastblock(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainLastblock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThorchainProxiedLastblock(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a proxied endpoint for the queue endpoint from a local thornode
         * @summary Get the Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThorchainProxiedQueue(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThorchainQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThorchainProxiedQueue(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TotalVolChanges>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalVolChanges(interval, from, to, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxDetails(offset, limit, address, txid, asset, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
         * @summary Get Asset Information
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInfo(asset: string, options?: any): AxiosPromise<Array<AssetDetail>> {
            return localVarFp.getAssetInfo(asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns earning report and apy of the specified pool.
         * @summary Get Pool Earning Detail
         * @param {string} pool Pool asset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningDetail(pool: string, options?: any): AxiosPromise<PoolEarningDetail> {
            return localVarFp.getEarningDetail(pool, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing the health response of the API.
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Network data
         * @summary Get Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options?: any): AxiosPromise<NetworkInfo> {
            return localVarFp.getNetworkData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Node public keys
         * @summary Get Node public keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: any): AxiosPromise<Array<NodeKey>> {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns historical aggregated details of the specified pool.
         * @summary Get Pool Aggregated Changes
         * @param {string} pool Pool asset name
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): AxiosPromise<Array<PoolAggChanges>> {
            return localVarFp.getPoolAggChanges(pool, interval, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing all the assets supported on BEPSwap pools
         * @summary Get Asset Pools
         * @param {'enabled' | 'bootstrap' | 'suspended'} [status] Pool status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status?: 'enabled' | 'bootstrap' | 'suspended', options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getPools(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing all the pool details for that asset.
         * @summary Get Pools Details
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any): AxiosPromise<Array<PoolDetail>> {
            return localVarFp.getPoolsDetails(asset, view, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing staking data for the specified staker and pool.
         * @summary Get Staker Pool Data
         * @param {string} address Unique staker address
         * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressAndAssetData(address: string, asset: string, options?: any): AxiosPromise<Array<StakersAssetData>> {
            return localVarFp.getStakersAddressAndAssetData(address, asset, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing all the pools the staker is staking in.
         * @summary Get Staker Data
         * @param {string} address Unique staker address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersAddressData(address: string, options?: any): AxiosPromise<StakersAddressData> {
            return localVarFp.getStakersAddressData(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing the addresses for all stakers.
         * @summary Get Stakers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStakersData(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getStakersData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing global stats for all pools and all transactions.
         * @summary Get Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): AxiosPromise<StatsData> {
            return localVarFp.getStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns stats and total changes of all pools in specified interval
         * @summary Get Stats Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): AxiosPromise<Array<StatsChanges>> {
            return localVarFp.getStatsChanges(interval, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a proxied endpoint for the constants endpoint from a local thornode
         * @summary Get the Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedConstants(options?: any): AxiosPromise<ThorchainConstants> {
            return localVarFp.getThorchainProxiedConstants(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
         * @summary Get the Proxied Pool Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedEndpoints(options?: any): AxiosPromise<ThorchainEndpoints> {
            return localVarFp.getThorchainProxiedEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a proxied endpoint for the lastblock endpoint from a local thornode
         * @summary Get the Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedLastblock(options?: any): AxiosPromise<ThorchainLastblock> {
            return localVarFp.getThorchainProxiedLastblock(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a proxied endpoint for the queue endpoint from a local thornode
         * @summary Get the Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThorchainProxiedQueue(options?: any): AxiosPromise<ThorchainQueue> {
            return localVarFp.getThorchainProxiedQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns total volume changes of all pools in specified interval
         * @summary Get Total Volume Changes
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
         * @param {number} from Start time of the query as unix timestamp
         * @param {number} to End time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any): AxiosPromise<Array<TotalVolChanges>> {
            return localVarFp.getTotalVolChanges(interval, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Return an array containing the event details
         * @summary Get details of a tx by address, asset or tx-id
         * @param {number} offset pagination offset
         * @param {number} limit pagination limit
         * @param {string} [address] Address of sender or recipient of any in/out tx in event
         * @param {string} [txid] ID of any in/out tx in event
         * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getTxDetails(offset, limit, address, txid, asset, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Detailed information about a specific asset. Returns enough information to display a unique asset in various user interfaces, including latest price.
     * @summary Get Asset Information
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAssetInfo(asset: string, options?: any) {
        return DefaultApiFp(this.configuration).getAssetInfo(asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns earning report and apy of the specified pool.
     * @summary Get Pool Earning Detail
     * @param {string} pool Pool asset name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEarningDetail(pool: string, options?: any) {
        return DefaultApiFp(this.configuration).getEarningDetail(pool, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing the health response of the API.
     * @summary Get Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealth(options?: any) {
        return DefaultApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing Network data
     * @summary Get Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNetworkData(options?: any) {
        return DefaultApiFp(this.configuration).getNetworkData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing Node public keys
     * @summary Get Node public keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNodes(options?: any) {
        return DefaultApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns historical aggregated details of the specified pool.
     * @summary Get Pool Aggregated Changes
     * @param {string} pool Pool asset name
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
     * @param {number} from Start time of the query as unix timestamp
     * @param {number} to End time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolAggChanges(pool: string, interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any) {
        return DefaultApiFp(this.configuration).getPoolAggChanges(pool, interval, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing all the assets supported on BEPSwap pools
     * @summary Get Asset Pools
     * @param {'enabled' | 'bootstrap' | 'suspended'} [status] Pool status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPools(status?: 'enabled' | 'bootstrap' | 'suspended', options?: any) {
        return DefaultApiFp(this.configuration).getPools(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing all the pool details for that asset.
     * @summary Get Pools Details
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {'balances' | 'simple' | 'full'} [view] Specifies the returning view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPoolsDetails(asset: string, view?: 'balances' | 'simple' | 'full', options?: any) {
        return DefaultApiFp(this.configuration).getPoolsDetails(asset, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing staking data for the specified staker and pool.
     * @summary Get Staker Pool Data
     * @param {string} address Unique staker address
     * @param {string} asset One or more comma separated unique asset (CHAIN.SYMBOL)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersAddressAndAssetData(address: string, asset: string, options?: any) {
        return DefaultApiFp(this.configuration).getStakersAddressAndAssetData(address, asset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing all the pools the staker is staking in.
     * @summary Get Staker Data
     * @param {string} address Unique staker address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersAddressData(address: string, options?: any) {
        return DefaultApiFp(this.configuration).getStakersAddressData(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array containing the addresses for all stakers.
     * @summary Get Stakers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStakersData(options?: any) {
        return DefaultApiFp(this.configuration).getStakersData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an object containing global stats for all pools and all transactions.
     * @summary Get Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStats(options?: any) {
        return DefaultApiFp(this.configuration).getStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns stats and total changes of all pools in specified interval
     * @summary Get Stats Changes
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
     * @param {number} from Start time of the query as unix timestamp
     * @param {number} to End time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStatsChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any) {
        return DefaultApiFp(this.configuration).getStatsChanges(interval, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a proxied endpoint for the constants endpoint from a local thornode
     * @summary Get the Proxied THORChain Constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedConstants(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedConstants(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a proxied endpoint for the pool_addresses endpoint from a local thornode
     * @summary Get the Proxied Pool Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedEndpoints(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a proxied endpoint for the lastblock endpoint from a local thornode
     * @summary Get the Proxied THORChain Lastblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedLastblock(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedLastblock(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a proxied endpoint for the queue endpoint from a local thornode
     * @summary Get the Proxied THORChain Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getThorchainProxiedQueue(options?: any) {
        return DefaultApiFp(this.configuration).getThorchainProxiedQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns total volume changes of all pools in specified interval
     * @summary Get Total Volume Changes
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'year'} interval Interval of calculations
     * @param {number} from Start time of the query as unix timestamp
     * @param {number} to End time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTotalVolChanges(interval: '5min' | 'hour' | 'day' | 'week' | 'month' | 'year', from: number, to: number, options?: any) {
        return DefaultApiFp(this.configuration).getTotalVolChanges(interval, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return an array containing the event details
     * @summary Get details of a tx by address, asset or tx-id
     * @param {number} offset pagination offset
     * @param {number} limit pagination limit
     * @param {string} [address] Address of sender or recipient of any in/out tx in event
     * @param {string} [txid] ID of any in/out tx in event
     * @param {string} [asset] Any asset used in event (CHAIN.SYMBOL)
     * @param {string} [type] One or more comma separated unique types of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTxDetails(offset: number, limit: number, address?: string, txid?: string, asset?: string, type?: string, options?: any) {
        return DefaultApiFp(this.configuration).getTxDetails(offset, limit, address, txid, asset, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentationApi - axios parameter creator
 * @export
 */
export const DocumentationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentationApi - functional programming interface
 * @export
 */
export const DocumentationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentationApiAxiosParamCreator(configuration)
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentationApi - factory interface
 * @export
 */
export const DocumentationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentationApiFp(configuration)
    return {
        /**
         * Swagger/openapi 3.0 specification generated documents.
         * @summary Get Documents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options?: any): AxiosPromise<void> {
            return localVarFp.getDocs(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentationApi - object-oriented interface
 * @export
 * @class DocumentationApi
 * @extends {BaseAPI}
 */
export class DocumentationApi extends BaseAPI {
    /**
     * Swagger/openapi 3.0 specification generated documents.
     * @summary Get Documents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentationApi
     */
    public getDocs(options?: any) {
        return DocumentationApiFp(this.configuration).getDocs(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpecificationApi - axios parameter creator
 * @export
 */
export const SpecificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecificationApi - functional programming interface
 * @export
 */
export const SpecificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSwagger(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSwagger(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpecificationApi - factory interface
 * @export
 */
export const SpecificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecificationApiFp(configuration)
    return {
        /**
         * Returns human and machine readable swagger/openapi specification.
         * @summary Get Swagger
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options?: any): AxiosPromise<void> {
            return localVarFp.getSwagger(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
export class SpecificationApi extends BaseAPI {
    /**
     * Returns human and machine readable swagger/openapi specification.
     * @summary Get Swagger
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    public getSwagger(options?: any) {
        return SpecificationApiFp(this.configuration).getSwagger(options).then((request) => request(this.axios, this.basePath));
    }
}


